# -*- coding: utf-8 -*-
"""Lab Guide 01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1izCGujeSyA9UMT0sqh2PYY_D3JIRrQOC

# Lab Guide 01 - Configuração do Ambiente
O **Google Colaboratory**, que também é conhecido como **Google Colab** ou simplesmente **Colab** é uma plataforma/serviço para trabalhar com ciência de dados e aprendizagem de máquina. Isso permite (re)usar configurações e compartilhar um ambiente com suporte a comandos *bash* e *Python* sobre uma série de bibliotecas, todas pré-instaladas e prontas para uso. Além disso, o Colab também provê aceleração por GPU e TPU.

Nesse exemplo configuraremos um ambiente para lidar com matrizes.

## [Passo 01] Conhecendo o **Colab**

Cada documento do Colab é um **notebook**, formado por código e .

O código está dividido em partes que podem ser executadas individualmente, chamadas de **células**. As células podem ser intercadadas com textos e imagens, permitindo documentar fartamente o processo desenvoldido, incluindo imagens, links, diagramas, etc.
"""

import sys
import numpy as np

if "__main__" == __name__ :
  """ Ponto de entrada para um programa standalone, mas geralmente irrelevante
      no contexto do Colab. Use Ctrl + Enter para executar a célula atual.
  """
  print(f"Olá Python {sys.version}");

"""Uma vez que a célula anterior foi executada, é possível acessar os objetos existentes, sejam variáveis, pacotes, classes ou funções. Por exemplo, podemos acessar a versão do pacote *numpy*, importado anteriormente como *np*:"""

# Essa célula continua a execução a partir da anterior
print( "versão do numpy: " + np.__version__ )

"""Uma das principais vantagens do Colab é abolir a complexidade de instalar a maior parte das bibliotecas, drivers e outras configurações complexas, demoradas e propensas ao erro. Comandos de terminal *bash* podem ser usados para configurações pontuais, devendo começar com o prefixo **!**:"""

!pwd
!ls -la

"""## [Passo 02] Multiplicação de Matrizes
A multiplicação de matrizes em *numpy* utiliza o método *dot()* ou *matmul()*. Por padrão, as matrizes são ordenadas de maneira *row-major*, ou seja, o primeiro índice identifica uma linha da matriz.

Isso significa que, para definir uma matriz-coluna, é necessário usar vários arrays aninhados em um array externo. Vejamos um exemplo a seguir:
"""

# matriz linha: 1x2
A = np.array( [[1.0 ,  2.0 ]] )
# matriz coluna: 2x1
B = np.array( [[3.0], [4.0]] )

# resultado: 1x1
C = A.dot(B)
# resultado: 2x2
D = B.dot(A)

print(f'C = {C}, with shape = {C.shape}')
print(f'D = {D}, with shape = {D.shape}')

print(f'trace(C) = { np.trace(C) }')
print(f'trace(D) = { np.trace(D) }')

"""## [Passo 03] Regressão Linear
Agora que você tem noções básicas de como funciona a configuração do ambiente, que tal ajustar um modelo simples? Começaremos pela Regressão Linear.

Primeiro vamos importar as bibliotecas necessárias:
"""

# operações de álgebra linear
import numpy as np
# visualização/plotagem
import matplotlib.pyplot as plt

"""Definamos o nosso conjunto de dados em duas dimensões, formado por dois arrays, **x** e **y**:"""

x = np.array( [3,21,22,34,54,34,55,67,89,99] )
y = np.array( [1,10,14,34,44,36,22,67,79,90] )

"""Vejamos como é simples visualizar nosso dataset usando um gŕafico de dispersão (*scatter plot*) usando a biblioteca **matplotlib**."""

plt.scatter( x, y )

"""Usaremos o método `polyfit` da biblitoeca numpy para estimar uma reta que melhor representa os dados obtidos de `x` e `y`:"""

fit = np.polyfit(x,y,1)
fit_fn = np.poly1d(fit)

"""Enquanto `fit` contém os coeficientes de regressão de ordem 1 - linear, `fit_fn` pode ser utiliada com a sintaxe `fit_fn(x)` para apresentar o valor de `y` estimado com a reta de regressão. Consulte mais detalhes sobre o método `polyfit` [na documentação](https://numpy.org/doc/stable/reference/generated/numpy.polyfit.html)

Por fim, exibimos os dados originais acrescidos da reta de regressão obtida, como a seguir:
"""

plt.plot(x,y, 'bo', x, fit_fn(x), 'k')